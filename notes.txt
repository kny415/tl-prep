initial enthusiasm is great, but it will wear off
the habit of focused practice will take the place of enthusiasm for continued progress and mastery
something must be sacrificed to develop these habits

what are you wrking towards?
	
  

i can be better than what anybody else thinks, and i can surpass any expectations i have for myself
i have failed over and over and over again, and that is why i succeed
limits like fears, are often just an illusion  

git
  git init      # creates new repo in current dir, generates .git directory
  git config    # sets author email and name
  git status    # show working directory and staged changes.  use this command liberally
  git add <filename>  # stage file changes, prepares them to be added to the repoi
  git commit -m "commit message" # creates a commit from staged files

  git remote add origin <url> # add github url for repo
  git push    # pushes commits from local repo to remote
  git push -u origin master
  git pull    # pulls commits from remote repo to local
  git clone    # pulls contents of existing remote repo into a new local repo and adds a remmote to the local repo
  git diff master origin/master   # shows changes

strings
  when to use single vs. double quotes
  "the man said, 'Hi there!'"     # 
  'the man said, \'Hi there!\''   # (\) escapes the single quote
  a = "ten"
  b = "My favorite number is #{a}!"   # string interpolation only works inside double quotes

symbols
  :name
  :a_symbol
  used when you want to reference something like a string but dont ever intend to print it or change it.  immutable/unchangeable

nil
  "Hello world".nil?    # returns false, it is not a nil type
  when used in an if expression, the if is treated as false

maths
  15/4    # 3
  15.0/4  # 3.75, if one of the numbers is a float, ruby returns a float
  'foo' + 'bar'   # "foobar"
  '12'.to_i + 2    # 14

hash rocket
  {:dog => 'barks', :cat => meows}

ruby expressions always return a value, even if that value is nil or an error

puts vs return
a = puts "stuff"
puts a    # returns nil


variables
  name = gets.chomp  # waits for user input, and removes the cariage return

  scope
    a block is a piece of code within {}'s or do/end
    not all do/end pairs imply a block
    inner scope can access outer scope variables, but not vice versa
    methods create their own scope, dont mix them up with do/ends
    each, times, and other methods create a new block
    5 types of variables:
    constants     # FIVE = 5
    global        # $var = 'global', available throughout app
    class         # @@instances = 0, accessible by class and instance
    instances     # @var = 'available in this instance'
    local         # var = "obeys all scope boundaries"

methods
  def say     # methods start with def
    # method logic
  end         # end method

  ruby is a pass-by-value and pass-by-reference language
  ruby methods always return the evaluated result of the last line of the expression, unless an explicit return comes before it

  chaining methods
  because every method returns something we can chain methods...
  add_three(5).times { puts 'this should print 8 times'}
  "hi there".length.to_s

  we can pass method calls as arguments to other methods
  multiply(add(20, 45), subtract(80, 10))   # => 4550

conditionals
  if x == 3 then puts "x is 3" end  # then needed for 1 liner ifs
  puts "x is 3" if x == 3

  true ? "this is true" : "this is false"
  false ? "this is true" : "this is false"

loops
  break     # exits the loop
  next      # skips everything below in the loop
  while vs until loops  # the conditional statement is reversed
  
  while <condition>
    #code
  end

  loop do
    # code
    if <condition>
      break
    end
  end
  
  for i in 1..x do
    # code
  end

  for i in x do
    puts i
  end

  iterators
    names = ['bob, 'joe', 'steve', 'janice', 'helen']
    names.each { |name| puts name }
    {} is the block and is used if contained in one line
    do/end is used if on multi lines
    names.each do |name|
      puts name
    end

arrays
  array = [1, 'Bob', 4.33, 'Another String'] # arrays can contain anything, even mixtures and other arrays
  array.first     # => 1
  array.last      # => "another string"
  array[2]        # => 4.33
  array.pop       # returns and removes last item of array
  array.push("astr")      # adds item to end of array
  array << "astr"         # same as .push
  a.map { |num| num**2 }  # iterates over entire array
  a.collect { |num| num**2 } # same as above
  a.delete_at(1)    # deletes item at index from array
  a.delete ("astr") # deletes item "astr"
  numbers.select { |num| num > 4 } # returns an array with values true
  a.unshift(1)      # adds 1 to the beginning of the array
  a.include?(3)
  a.flatten
  a.each_with_index { |val, idx| puts "#{val}: #{idx}"}
  a.sort
  a.each vs a.map, a.each iterates and returns original array.  a.map iterates and returns a new array
  a.index(5)    # finds 5 in the array and returns the index


hash
  old_syntax_hash = {:name => 'bob'}
  new_hash = {name: 'bob'}
  new_hash[:age] = 62       #{} : is after, [] : is before
  
  def greeting(name, options = {})
    if options.empty?  #...
  greeting("bob", {age: 62, city: "sf"})

  anything can be a hash key, just use the old syntax
  {["height"] => "6 ft"}
  {45.6 => "forty five.six"}

  new_hash.has_key?("bob")    # => true
  new_hash.select { |k, v| k == 'bob'}    # => {"bob"=>42}
  new_hash.fetch("bob")   # => 62
  new_hash.keys     # => returns all keys in the hash
  new_hash.values   # => returns all values in the hash
  new_hash.each do |k, v|
